#!/usr/bin/env node
'use strict';

const child_process = require('child_process');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

const shell = cmd => child_process.execSync(cmd, {stdio: 'inherit', cwd: __dirname});
const hash = files => {
  const h = crypto.createHash('md5');
  for (const f of files) {
    h.update(fs.readFileSync(path.join(__dirname, f)));
  }
  return h.digest('hex').substr(0, 8);
}

try {
  require.resolve('./data/clean_1w.txt');
} catch (e) {
  shell('./tools/fix.js');
}

try {
  require.resolve('./data/dict.json');
  require.resolve('./data/stats.json');
} catch (e) {
  shell('./tools/dict.js');
}

shell('npm run compile');

const FILES = [
  '/index.html',
  '/favicon.ico',
  '/style.css',
  '/manifest.json',
  '/js/game.js',
  '/js/longpress.js',
  '/js/swipe.js',
  '/js/random.js',
  '/js/timer.js',
  '/js/store.js',
  '/js/training.js',
  '/js/trie.js',
  '/js/dict.js',
  '/js/stats.js',
  '/js/ui/view.js',
  '/js/ui/score.js',
  '/js/ui/settings.js',
  '/js/ui/debug.js',
  '/img/refresh.svg',
  '/img/back.svg',
  '/img/play.svg',
  '/img/practice.svg',
  '/img/android-chrome-192x192.png',
  '/img/android-chrome-512x512.png',
  '/img/apple-touch-icon.png',
  '/fonts/roboto-400-italic.woff',
  '/fonts/roboto-400.woff',
  '/fonts/roboto-700.woff',
  '/fonts/roboto-700-italic.woff',
  '/fonts/roboto-400.woff2',
  '/fonts/roboto-400-italic.woff2',
  '/fonts/roboto-700.woff2',
  '/fonts/roboto-700-italic.woff2',
];

fs.writeFileSync(path.join(__dirname, 'sw.js'), `'use strict';

const CACHE = 'cache:${hash(FILES)}';
const DATA = 'data:${hash(['/data/dict.json', '/data/stats.json'])}';

self.addEventListener('install', e => {
    self.skipWaiting();
    e.waitUntil(
        caches.open(CACHE).then(cache =>
            cache.addAll(${JSON.stringify(FILES, null, 2)})));
});

self.addEventListener('activate', e =>
    e.waitUntil(
        caches.keys().then(keys =>
            Promise.all(keys.map(key => {
                if (key !== CACHE && key !== DATA) return caches.delete(key);
            })))));

const writeBack = (e, which) =>
    caches.open(which).then(async cache => {
        const cached = await cache.match(e.request);
        if (cached) return cached;
        const response = await fetch(e.request);
        if (response.status === 200) cache.put(e.request.url, response.clone());
        return response;
    });

self.addEventListener('fetch', e => {
    if (e.request.url.includes('/data/dict.json') ||
        e.request.url.includes('/data/stats.json')) {
      e.respondWith(writeBack(e, DATA));
    } else {
      e.respondWith(writeBack(e, CACHE));
    }
});
`);




