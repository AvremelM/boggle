<!doctype html>
<html lang=en>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="description" content="Boggle">
  <meta name="theme-color" content="#FFF" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Boggle">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="favicon.ico">
  <link rel="manifest" href="manifest.json">
  <title>Boggle</title>
  <style>
    /* LG-H873 = 360 x 588  */
    body {
      font-family: "Roboto", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
      margin: 0px;
      touch-action: none;
      user-select: none;
    }
    ::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }
    #display {
      width: 360px;
      height: 588px;
      margin: 0px auto;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    #loader, #content {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #loader {
      height: 60%;
    }
    #topbar {
      height: 68px;
      line-height: 68px;
      vertical-align: middle;
      font-size: 20px;
      display: flex;
      flex-direction: row;
      text-align: center;
      font-weight: bold;
    }
    #refresh, #score, #back {
      width: 20%;
    }
    #timer {
      width: 60%;
      font-size: 40px;
    }
    #timer.expired {
      color: red;
    }
    #word {
      width: 100%;
      height: 68px;
      line-height: 68px;
      vertical-align: middle;
      text-align: center;
      font-size: 40px;
      font-weight: bold;
      text-transform: uppercase;
    }
    #word:focus {
      outline: none;
    }
    #defn {
      text-align: center;
      margin: 0px auto;
      width: 90%;
    }
    #board {
      font-size: 68px;
      font-weight: bold;
      touch-action: auto;
      margin: 5px 0;
    }
    #board td {
      text-align: center;
      border: 3px solid black;
      height: 80px;
      width: 80px;
      border-radius: 8px;
    }
    .target {
      height: 70px;
      width: 70px;
      position: absolute;
      margin: -75px 5px;
      z-index: 100;
    }
    #board.big {
      font-size: 54px;
    }
    #board.big td { 
      height: 64px;
      width: 64px;
    }
    #board.big .target {
      height: 54px;
      width: 54px;
      margin: -60px 5px;
    }
    .qu {
      font-size: 90%;
    }
    .hidden {
      display: none !important;
    }
    #board td.selected {
      background: lightblue;
    }
    #wrapper {
      height: 100%;
      overflow: scroll;
    }
    .results {
      width: 100%;
      padding: 5px;
      z-index: -1;
    }
    .hard {
      color: #aaa;
    }
    .overtime {
      font-style: italic;
    }
    .suffix {
      text-decoration: underline;
    }
    .collapsible {
      background-color: #fff;
      cursor: pointer;
      padding: 18px;
      width: 95%;
      display: block;
      margin: 3px auto;
      border: 3px solid black;
      border-radius: 8px;
      text-align: left;
      outline: none;
      font-family: "Roboto", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
      background-color: #fafafa;
    }
    .title {
      font-weight: bold;
    }
    .collapsible-content {
      padding: 5px 18px;
      display: none;
      overflow: hidden;
    }
    .collapsible-content .collapsible-content {
      border: 3px solid black;
      border-top: none;
      border-radius: 0px 0px 8px 8px;
      margin-bottom: 5px;
      min-height: 3em;
    }
    .collapsible-content .collapsible {
      width: 100%;
      margin-bottom: 5px;
    }
    .collapsible-content .collapsible.active {
      margin-bottom: 0px;
      border-radius: 8px 8px 0px 0px;
    }
    .collapsible:after {
      content: '\02795';
      color: transparent;
      text-shadow: 0 0 0 black;
      float: right;
      margin-left: 5px;
    }
    .active:after {
      content: '\02796';
    }
    .collapsible div {
      width: 90%;
      display: inline-block;
    }
    .details {
      float: right;
    }
    @keyframes fade {
      100% { opacity: 0 };
    }
    .error {
      color: red;
    }
    .fade {
      animation-name: fade;
      animation-duration: 0.5s;
    }
    @keyframes spinner {
      to { transform: rotate(360deg); }
    }
    #spinner {
      display: inline-block;
      width: 2rem;
      height: 2rem;
      vertical-align: text-bottom;
      border: .25em solid currentColor;
      border-right-color: transparent;
      border-radius: 50%;
      -webkit-animation: spinner .75s linear infinite;
      animation: spinner .75s linear infinite;
    }
    .rotate90 { transform: rotate(90deg); }
    .rotate180 { transform: rotate(180deg); }
    .rotate270 { transform: rotate(270deg); }
    .underline { text-decoration: underline; }

    /* Pixel = 393 x 714 */
    @media(min-width: 393px) {
      #display {
        width: 393px;
        height: 714px;
      }
      #board {
        margin: 40px 0;
      }
    }

    /* iPhone 6S Plus = 414 x 736 */
    /* TODO */

    /* Tablet */
    @media(min-width: 768px) {
      body {
        margin-top: 20px;
      }
    }

    /* Installed (no URL bar) */
    @media all and (display-mode: standalone) {
      body { margin-top: 20px; }
      #content {
        margin: 10px 0px;
      }
    }
  </style>
</head>
<body>
  <div id="display">
    <div id="loader">
      <div id="spinner"></div>
    </div>
    <div id="game" class="hidden">
      <header id="topbar">
        <div id="refresh"><img height="20" src="img/refresh.svg" /></div>
        <div id="back" class="hidden"><img height="20" src="img/back.svg" /></div>
        <div id="timer">3:00</div>
        <div id="score">0</div>
      </header>
      <div id="content">
      </div>
      <div id="word"></div>
      <div id="defn"></div>
    </div>
  </div>
  <script type="application/javascript" src="boggle.js"></script>
  <script type="application/javascript" src="longpress.js"></script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').then(reg => {
          console.log('Service worker registered.', reg);
        });
      });
    }

    const HISTORY = JSON.parse(localStorage.getItem('history')) || [];
    const SETTINGS = JSON.parse(localStorage.getItem('settings')) || {dice: 'New', dict: 'TWL', grade: 'C'};
    var STATE = null;

    class Timer {
      constructor(duration) {
        this.elapsed = 0;
        this.duration = duration;
        this.display = document.getElementById('timer');
        this.display.classList.remove('expired');
        this.interval = null;
        this.paused = null;
      }

      start() {
        if (!this.elapsed) {
          this.begin = new Date().getTime();
          this.last = this.begin;
          this.interval = setInterval(() => this.update(), 100);
        }
      }

      stop() {
        if (this.interval) {
          this.interval = clearInterval(this.interval);
          this.inteval = null;
        }
      }

      pause() {
        if (this.interval) {
          this.interval = clearInterval(this.interval);
          this.interval = null;
          this.begin = new Date().getTime();
          this.elapsed += this.begin - this.last;
          this.last = this.begin;
        } else {
          this.begin = new Date().getTime();
          this.last = this.begin;
          this.interval = setInterval(() => this.update(), 100);
        }
      }

      expired() {
        return this.elapsed >= this.duration;
      }

      update() {
        const now = new Date().getTime();
        this.elapsed += now - this.last;
        this.last = now;

        let distance;
        if (this.expired()) {
          this.display.classList.add('expired');
          distance = this.elapsed - this.duration;
          if (!STATE.game.expired) STATE.game.expired = +new Date();
        } else {
          distance = this.duration - this.elapsed;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = `${Math.floor((distance % (1000 * 60)) / 1000)}`.padStart(2, '0');

        this.display.textContent = `${minutes}:${seconds}`;
      }
    }

    function setup() {
      if (document.location.hash && document.location.hash.length > 1) {
        const [settings, seed] = Game.decodeID(document.location.hash.slice(1));
        if (!isNaN(seed)) return [settings, seed];
      }

      if (HISTORY.length) {
        const id = HISTORY[HISTORY.length - 1].seed;
        const [settings, seed] = Game.decodeID(id);
        const rand = new Random(seed);
        rand.next();

        return [settings, rand.seed];
      }

      return [SETTINGS, 0];
    }

    (async () => {
      setTimeout(() => window.scrollTo(0, 1), 0);

      const response = await fetch('data/dict.json', {mode: 'no-cors'});
      const DICT = await response.json();

      const [settings, SEED] = setup();
      Object.assign(SETTINGS, settings);
      localStorage.setItem('settings', JSON.stringify(SETTINGS));

      document.getElementById('display').removeChild(document.getElementById('loader'));
      document.getElementById('game').classList.remove('hidden');

      const TRIE = new Trie(DICT);

      STATE = refresh();

      const TOUCH = ('ontouchstart' in window) ||
        (navigator.maxTouchPoints > 0) || 
        (navigator.msMaxTouchPoints > 0);

      const menu = document.getElementById('menu');
      const word = document.getElementById('word');
      const defn = document.getElementById('defn');
      if (!TOUCH) {
        word.contentEditable = true;
        word.focus();
      }

      let kept = false;
      const clearWord = w => {
        if (w && w !== word.textContent) return;
        word.textContent = '';
        word.classList.remove('error');
        word.classList.remove('fade');
        defn.textContent = '';
        kept = false;
      };

      // TODO: use...
      function adjacent(a, b) {
        return Math.abs(b.dataset.x - a.dataset.x) <= 1 && Math.abs(b.dataset.y - a.dataset.y) <= 1;
      }

      function refresh(state, settings, seed) {
        let random;
        if (state) {
          HISTORY.push(state.game.toJSON());
          localStorage.setItem('history', JSON.stringify(HISTORY));
          state.timer.stop();
          random = state.game.random;
        }

        const timer = new Timer(180 * 1000);
        random = !isNaN(seed) ? new Random(seed) : (random || new Random(SEED));
        const game = new Game(TRIE, DICT, random, settings);
        const content = document.getElementById('content');
        if (content.firstChild) content.removeChild(content.firstChild);

        const table = document.createElement('table');
        table.setAttribute('id', 'board');
        if (game.size > 4) table.classList.add('big');

        for (let row = 0; row < game.size; row++) {
          const tr = document.createElement('tr');
          for (let col = 0; col < game.size; col++) {
            const td = document.createElement('td');
            td.textContent = game.board[row*game.size + col];
            if (td.textContent === 'Qu') td.classList.add('qu');
            if (['M', 'W', 'Z'].includes(td.textContent)) td.classList.add('underline');
            td.classList.add(`rotate${90 * random.next(0, 4)}`);
            td.setAttribute('data-x', row);
            td.setAttribute('data-y', col);

            const div = document.createElement('div');
            div.classList.add('target');
            div.setAttribute('data-x', row);
            div.setAttribute('data-y', col);

            td.appendChild(div);
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }
        
        let touched;
        let lastTouched = null;
        const deselect = () => {
          if (!touched) return;
          for (const td of touched) {
            td.classList.remove('selected');
          }
        };
        table.addEventListener('touchstart', () => {
          clearWord();
          deselect();
          touched = new Set();
          lastTouched = null;
        });
        table.addEventListener('touchend', () => {
          deselect();
          play(STATE, word);
        });
        table.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          const cell = document.elementFromPoint(touch.clientX, touch.clientY);
          if (cell && cell.matches('.target')) {
            // TODO: make sure is adjacent to last td!
            /* if (lastTouched && !adjacent(cell, lastTouched)) {
              deselect();
              play(STATE, word);
            } */
            const td = cell.parentNode;
            td.classList.add('selected');
            if (!touched.has(td)) {
              touched.add(td);
              lastTouched = cell;
              word.textContent += td.textContent;
            }
          }
        });

        content.appendChild(table);
        document.getElementById('score').textContent = game.settings.blind ? '?' : '0';

        // Cleanup
        const wrapper = document.getElementById('wrapper');
        if (wrapper) document.getElementById('display').removeChild(wrapper);

        const word = document.getElementById('word');
        word.textContent = '';
        word.classList.remove('hidden');
        word.classList.remove('error');
        word.classList.remove('fade');

        const defn = document.getElementById('defn');
        defn.textContent = '';
        defn.classList.remove('hidden');

        timer.start();
        if (document.location.hash !== `#${game.id}`) {
          window.history.pushState(null, null, `#${game.id}`);
        }

        return {timer, game};
      }

      function formatScore(score) {
        return score.overtime ? `${score.regular} / ${score.overtime}` : `${score.regular}`;
      }

      function play(state, word) {
        const w = word.textContent.toUpperCase();
        const score = state.game.play(w);
        const display = !state.game.settings.blind && score;
        kept = true;
        if (display) {
          document.getElementById('score').textContent = formatScore(state.game.score);
          document.getElementById('defn').textContent = DICT[w].defn;
        } else {
          const o = word.textContent;
          if (!state.game.settings.blind && state.game.played[w] < 0) word.classList.add('error');
          word.classList.add('fade');
          const animationend = () => {
            clearWord(o);
            word.removeEventListener('animationend', animationend);
          }
          word.addEventListener('animationend', animationend);
        }
      }

      window.addEventListener('hashchange', e => {
        if (!document.location.hash) return; // is just a reload...
        const [settings, seed] = Game.decodeID(document.location.hash.slice(1));

        if (!isNaN(seed)) {
          Object.assign(SETTINGS, settings);
          localStorage.setItem('settings', JSON.stringify(SETTINGS));
        }

        STATE = refresh(STATE, settings, seed);
      });

      document.getElementById('refresh').addEventListener('mouseup', () => {
        STATE = refresh(STATE);
      });

      document.getElementById('refresh').addEventListener('long-press', e => {
        console.log('REFRESH LONG PRESS'); // FIXME
        //document.getElementById('menu').classList.toggle('hidden');
        // TODO: unhide type menu, rehide if click outside of menu area!
      });

      document.getElementById('timer').addEventListener('click', () => {
        STATE.timer.pause();
      });

      function makeCollapsible(title, details, display, fn) {
        const button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.classList.add('collapsible');

        const div = document.createElement('div');

        const titleSpan = document.createElement('span');
        titleSpan.classList.add('title');
        titleSpan.textContent = title;

        const detailsSpan = document.createElement('span');
        detailsSpan.classList.add('details');
        detailsSpan.textContent = details;

        div.appendChild(titleSpan);
        div.appendChild(detailsSpan);
        button.appendChild(div);

        button.addEventListener('click', function() {
          this.classList.toggle('active');
          const content = this.nextElementSibling;
          if (content.style.display === display) {
            content.style.display = 'none';
          } else {
            if (fn) fn();
            content.style.display = display;
          }
        });

        return button;
      }

      function displayPlayed(state, div, expanded) {
        const p = state.progress;
        const details = `${p.suffixes}/${p.subwords}/${p.anagrams}/${p.invalid} (${p.total})`;

        const button = makeCollapsible('PLAYED', details, 'table');

        const table = document.createElement('table');
        table.classList.add('collapsible-content');
        table.classList.add('results');
        table.classList.add('played');

        for (const {word, grade, overtime, root, defn, invalid} of state.played) {
          const tr = document.createElement('tr');
          if (grade < SETTINGS.grade) tr.classList.add('hard');
          if (invalid) tr.classList.add('error');
          if (overtime) tr.classList.add('overtime');

          let td = document.createElement('td');
          const b = document.createElement('b');
          if (root) {
            const rootSpan = document.createElement('span');
            rootSpan.textContent = root;
            const suffixSpan = document.createElement('span');
            suffixSpan.classList.add('suffix');
            suffixSpan.textContent = word.slice(root.length);
            b.appendChild(rootSpan);
            b.appendChild(suffixSpan);
          } else {
            b.textContent = word;
          }
          td.appendChild(b);
          tr.appendChild(td);

          td = document.createElement('td');
          if (defn) td.textContent = defn;
          tr.appendChild(td);

          table.appendChild(tr);
        }

        if (expanded) {
          button.classList.add('active');
          table.style.display = 'table';
        }

        div.appendChild(button);
        div.appendChild(table);
      }

      function displayPossible(state, div, expanded) {
        const tot = state.totals;
        const details = `${tot.d}/${tot.c}/${tot.b}/${tot.a} (${tot.s})`;

        const button = makeCollapsible('POSSIBLE', details, 'table');
        const table = document.createElement('table');
        table.classList.add('collapsible-content');
        table.classList.add('results');
        table.classList.add('possible');

        for (const {word, grade, overtime, root, defn} of state.remaining) {
          const tr = document.createElement('tr');
          if (grade < SETTINGS.grade) tr.classList.add('hard');
          if (overtime) tr.classList.add('overtime');

          let td = document.createElement('td');
          const b = document.createElement('b');
          if (root) {
            const rootSpan = document.createElement('span');
            rootSpan.textContent = root;
            const suffixSpan = document.createElement('span');
            suffixSpan.classList.add('suffix');
            suffixSpan.textContent = word.slice(root.length);
            b.appendChild(rootSpan);
            b.appendChild(suffixSpan);
          } else {
            b.textContent = word;
          }
          td.appendChild(b);
          tr.appendChild(td);

          td = document.createElement('td');
          td.textContent = defn;
          tr.appendChild(td);

          table.appendChild(tr);
        }

        if (expanded) {
          button.classList.add('active');
          table.style.display = 'table';
        }

        div.appendChild(button);
        div.appendChild(table);
      }

      document.getElementById('score').addEventListener('long-press', e => {
        const size = STATE.game.size;
        const weights = [];
        for (let row = 0; row < size; row++) {
          const a = [];
          for (let col = 0; col < size; col++) {
            a.push(0);
          }
          weights.push(a);
        }
        let total = 0;
        for (const word in STATE.game.possible) {
          if (STATE.game.played[word]) continue;
          const score = Game.score(word);
          total += score;
          for (const p of STATE.game.possible[word]) {
            weights[p[1]][p[0]] += score;
          }
        }

        for (const td of document.getElementById('board').getElementsByTagName('td')) {
          const w = weights[Number(td.dataset.x)][Number(td.dataset.y)] / total;
          td.style.backgroundColor = `rgba(255,0,0,${w})`;
        }
      });

      document.getElementById('score').addEventListener('long-press-up', e => {
        for (const td of document.getElementById('board').getElementsByTagName('td')) {
          td.style.backgroundColor = 'inherit';
        }
      });

      document.getElementById('score').addEventListener('mouseup', () => {
        const wrapper = document.getElementById('wrapper');
        if (!wrapper) {
          const display = document.getElementById('display');
          const board = document.getElementById('board');
          board.classList.add('hidden');
          word.classList.add('hidden');
          defn.classList.add('hidden');
          document.getElementById('refresh').classList.add('hidden');
          document.getElementById('back').classList.remove('hidden');

          const wrapper = document.createElement('div');
          wrapper.setAttribute('id', 'wrapper');

          const state = STATE.game.state();
          const score = STATE.game.score.regular + STATE.game.score.overtime;
          const goal = state.totals[SETTINGS.grade.toLowerCase()];
          const details = `${score}/${goal} (${Math.round(score / goal * 100).toFixed(0)}%)`;
          const current = makeCollapsible(STATE.game.toJSON().seed, details, 'block');
          const div = document.createElement('div');
          div.classList.add('collapsible-content');
          displayPlayed(state, div, true);
          displayPossible(state, div);
          wrapper.appendChild(current);
          wrapper.appendChild(div);
          // Start off with played expanded
          current.classList.add('active');
          div.style.display = 'block';

          for (let i = HISTORY.length - 1; i > 0; i--) {
            const state = HISTORY[i];
            let score = 0;
            for (const [w, t] of Object.entries(state.words)) {
              if (t > 0) score += Game.score(w);
            }
            if (!score) continue;

            const details = `${score}/${state.goal[SETTINGS.grade]} (${Math.round(score / state.goal[SETTINGS.grade] * 100).toFixed(0)}%)`;
            const div = document.createElement('div');
            div.classList.add('collapsible-content');
            div.classList.add('lazy');
            const button = makeCollapsible(state.seed, details, 'block', () => {
              if (div.classList.contains('lazy')) {
                div.classList.remove('lazy');
                const game = Game.fromJSON(state, TRIE, DICT);
                const s = game.state();
                displayPlayed(s, div);
                displayPossible(s, div);
              }
            });
            wrapper.appendChild(button);
            wrapper.appendChild(div);
          }

          display.appendChild(wrapper);
        } else {
          backToGame();
        }
      });

      document.getElementById('back').addEventListener('click', backToGame);

      function backToGame() {
        const display = document.getElementById('display');
        const board = document.getElementById('board');
        const wrapper = document.getElementById('wrapper');

        // TODO FIXME: hide instead of remove to avoid recompute...
        display.removeChild(wrapper);

        board.classList.remove('hidden');
        word.classList.remove('hidden');
        defn.classList.remove('hidden');
        document.getElementById('refresh').classList.remove('hidden');
        document.getElementById('back').classList.add('hidden');
      }

      // TODO: shouldnt work when in score mode!
      document.addEventListener('keydown', e => {
        if (kept) clearWord();
        word.focus(); // TODO: fix cursor locaton
        const key = e.keyCode;
        if (key === 13 || key === 32) {
          play(STATE, word);
          e.preventDefault(); 
          word.focus();
        } else if ((key < 65 || key > 90) && key !== 8) {
          e.preventDefault();
        }
      });
    })();
  </script>
</body>
</html>
