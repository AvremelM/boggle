<!doctype html>
<html lang=en>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="icon" href="favicon.ico">
  <title>Boggle</title>
  <style>
    /* Mobile - Small */
    body {
      font-family: "Roboto", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
      margin: 0px;
      touch-action: none;
      user-select: none;
    }
    ::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }
    #display {
      width: 393px;
      height: 714px;
      margin: 0px auto;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    #loader, #content {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #loader {
      height: 60%;
    }
    #topbar {
      height: 70px;
      line-height: 70px;
      vertical-align: middle;
      font-size: 20px;
      display: flex;
      flex-direction: row;
      text-align: center;
      font-weight: bold;
    }
    #refresh, #score {
      width: 20%;
    }
    #timer {
      width: 60%;
      font-size: 40px;
    }
    #timer.expired {
      color: red;
    }
    #word {
      width: 100%;
      height: 70px;
      line-height: 70px;
      vertical-align: middle;
      text-align: center;
      font-size: 40px;
      font-weight: bold;
      text-transform: uppercase;
    }
    #word:focus {
      outline: none;
    }
    #defn {
      text-align: center;
      margin: 0px auto;
      width: 90%;
    }
    #board {
      font-size: 70px;
      font-weight: bold;
      touch-action: auto;
      margin: 40px 0;
    }
    #board td {
      text-align: center;
      border: 3px solid black;
      height: 80px;
      width: 80px;
      border-radius: 8px;
    }
    .target {
      height: 70px;
      width: 70px;
      position: absolute;
      margin: -75px 5px;
      z-index: 100;
    }
    #board.big {
      font-size: 56px;
    }
    #board.big td { 
      height: 64px;
      width: 64px;
    }
    #board.big .target {
      height: 56px;
      width: 56px;
      margin: -60px 5px;
    }
    .qu {
      font-size: 90%;
    }
    .hidden {
      display: none !important;
    }
    #board td.selected {
      background: lightblue;
    }
    #wrapper {
      height: 100%;
      overflow: scroll;
    }
    .results {
      width: 100%;
      padding: 5px;
      z-index: -1;
    }
    .hard {
      color: #aaa;
    }
    .group {
      font-style: italic;
    }
    .suffix {
      text-decoration: underline;
    }
    .collapsible {
      background-color: #fff;
      cursor: pointer;
      padding: 18px;
      width: 95%;
      display: block;
      margin: 0px auto;
      border: 3px solid black;
      border-radius: 8px;
      text-align: left;
      outline: none;
      font-family: "Roboto", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
      font-weight: bold;
      background-color: #fafafa;
    }
    .collapsible-content {
      padding: 5px 18px;
      display: none;
      overflow: hidden;
    }
    .collapsible-content .collapsible-content {
      border: 3px solid black;
      border-top: none;
      border-radius: 0px 0px 8px 8px;
      margin-bottom: 5px;
      min-height: 3em;
    }
    .collapsible-content .collapsible {
      width: 100%;
      margin-bottom: 5px;
    }
    .collapsible-content .collapsible.active {
      margin-bottom: 0px;
      border-radius: 8px 8px 0px 0px;
    }
    .collapsible:after {
      content: '\02795';
      color: transparent;
      text-shadow: 0 0 0 black;
      float: right;
      margin-left: 5px;
    }
    .active:after {
      content: '\02796';
    }
    @keyframes fade {
      100% { opacity: 0 };
    }
    .error {
      color: red;
    }
    .fade {
      animation-name: fade;
      animation-duration: 0.5s;
    }
    @keyframes spinner {
      to { transform: rotate(360deg); }
    }
    #spinner {
      display: inline-block;
      width: 2rem;
      height: 2rem;
      vertical-align: text-bottom;
      border: .25em solid currentColor;
      border-right-color: transparent;
      border-radius: 50%;
      -webkit-animation: spinner .75s linear infinite;
      animation: spinner .75s linear infinite;
    }
    .rotate90 { transform: rotate(90deg); }
    .rotate180 { transform: rotate(180deg); }
    .rotate270 { transform: rotate(270deg); }
    /* Mobile - Medium */
    @media(min-width: 375px) { }
    /* Mobile - Large */
    @media(min-width: 425px) { }
    /* Tablet */
    @media(min-width: 768px) {
      body {
        margin-top: 20px;
      }
    }
    /* Laptop */
    @media(min-width: 1024px) {
    }
  </style>
</head>
<body>
  <div id="display">
    <div id="loader">
      <div id="spinner"></div>
    </div>
    <div id="game" class="hidden">
      <header id="topbar">
        <div id="refresh"><img height="20" src="img/refresh.svg" /></div>
        <div id="timer">3:00</div>
        <div id="score">0</div>
      </header>
      <div id="content">
      </div>
      <div id="word"></div>
      <div id="defn"></div>
    </div>
  </div>
  <script type="application/javascript" src="boggle.js"></script>
  <script>
    var STATE = null;

    class Timer {
      constructor(duration) {
        this.elapsed = 0;
        this.duration = duration;
        this.display = document.getElementById('timer');
        this.display.classList.remove('expired');
        this.interval = null;
        this.paused = null;
      }

      start() {
        if (!this.elapsed) {
          this.begin = new Date().getTime();
          this.last = this.begin;
          this.interval = setInterval(() => this.update(), 100);
        }
      }

      stop() {
        if (this.interval) {
          this.interval = clearInterval(this.interval);
          this.inteval = null;
        }
      }

      pause() {
        if (this.interval) {
          this.interval = clearInterval(this.interval);
          this.interval = null;
          this.begin = new Date().getTime();
          this.elapsed += this.begin - this.last;
          this.last = this.begin;
        } else {
          this.begin = new Date().getTime();
          this.last = this.begin;
          this.interval = setInterval(() => this.update(), 100);
        }
      }

      expired() {
        return this.elapsed >= this.duration;
      }

      update() {
        const now = new Date().getTime();
        this.elapsed += now - this.last;
        this.last = now;

        let distance;
        if (this.expired()) {
          this.display.classList.add('expired');
          distance = this.elapsed - this.duration;
          if (!STATE.game.expired) STATE.game.expired = +new Date();
        } else {
          distance = this.duration - this.elapsed;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = `${Math.floor((distance % (1000 * 60)) / 1000)}`.padStart(2, '0');

        this.display.textContent = `${minutes}:${seconds}`;
      }
    }

    (async () => {
      setTimeout(() => window.scrollTo(0, 1), 0);

      const response = await fetch('data/dict.json', {mode: 'no-cors'});
      const DICT = await response.json();

      document.getElementById('display').removeChild(document.getElementById('loader'));
      document.getElementById('game').classList.remove('hidden');

      const TRIE = new Trie(DICT);
      const RANDOM = new Random(Math.floor(Math.random() * 124861247)); // TODO

      STATE = refresh();

      const TOUCH = ('ontouchstart' in window) ||
        (navigator.maxTouchPoints > 0) || 
        (navigator.msMaxTouchPoints > 0);

      const word = document.getElementById('word');
      const defn = document.getElementById('defn');
      if (!TOUCH) {
        word.contentEditable = true;
        word.focus();
      }

      let kept = false;
      const clearWord = w => {
        if (w && w !== word.textContent) return;
        word.textContent = '';
        word.classList.remove('error');
        word.classList.remove('fade');
        defn.textContent = '';
        kept = false;
      };

      const adjacent = (a, b) =>
        Math.abs(b.dataset.x - a.dataset.x) <= 1 && Math.abs(b.dataset.y - a.dataset.y) <= 1;

      function refresh(state) {
        if (state) state.timer.stop();
        const timer = new Timer(180 * 1000);

        const game = new Game(DICE, TRIE, DICT, RANDOM); // TODO BIG_DICE / OLD_DICE
        const content = document.getElementById('content');
        if (content.firstChild) content.removeChild(content.firstChild);

        const table = document.createElement('table');
        table.setAttribute('id', 'board');
        if (game.size > 4) table.classList.add('big');
        for (let row = 0; row < game.size; row++) {
          const tr = document.createElement('tr');
          for (let col = 0; col < game.size; col++) {
            const td = document.createElement('td');
            td.textContent = game.board[row*game.size + col];
            if (td.textContent === 'Qu') td.classList.add('qu');
            td.classList.add(`rotate${90*RANDOM.next(0, 4)}`);
            const div = document.createElement('div');
            div.classList.add('target');
            div.setAttribute('data-x', row);
            div.setAttribute('data-y', col);
            td.appendChild(div);
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }
        
        let touched;
        let lastTouched = null;
        const deselect = () => {
          if (!touched) return;
          for (const td of touched) {
            td.classList.remove('selected');
          }
        };
        table.addEventListener('touchstart', () => {
          clearWord();
          deselect();
          touched = new Set();
          lastTouched = null;
        });
        table.addEventListener('touchend', () => {
          deselect();
          play(STATE, word);
        });
        table.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          const cell = document.elementFromPoint(touch.clientX, touch.clientY);
          if (cell && cell.matches('.target')) {
            // TODO: make sure is adjacent to last td!
            /* if (lastTouched && !adjacent(cell, lastTouched)) {
              deselect();
              play(STATE, word);
            } */
            const td = cell.parentNode;
            td.classList.add('selected');
            if (!touched.has(td)) {
              touched.add(td);
              lastTouched = cell;
              word.textContent += td.textContent;
            }
          }
        });

        content.appendChild(table);
        document.getElementById('score').textContent = 0;

        // Cleanup
        const wrapper = document.getElementById('wrapper');
        if (wrapper) document.getElementById('display').removeChild(wrapper);
        const word = document.getElementById('word');
        word.textContent = '';
        word.classList.remove('hidden');
        word.classList.remove('error');
        word.classList.remove('fade');
        const defn = document.getElementById('defn');
        defn.textContent = '';

        timer.start();
        return {timer, game};
      }

      const formatScore = score => score.overtime ? `${score.regular} / ${score.overtime}` : `${score.regular}`;

      function play(state, word) {
        const w = word.textContent.toUpperCase();
        const score = state.game.play(w);
        document.getElementById('score').textContent = formatScore(state.game.score);
        kept = true;
        if (score) {
          document.getElementById('defn').textContent = DICT[w].defn;
        } else {
          const o = word.textContent;
          if (!state.game.played[w]) word.classList.add('error');
          word.classList.add('fade');
          const animationend = () => {
            clearWord(o);
            word.removeEventListener('animationend', animationend);
          }
          word.addEventListener('animationend', animationend);
        }
      }

      document.getElementById('refresh').addEventListener('click', () => {
        STATE = refresh(STATE);
      });

      document.getElementById('timer').addEventListener('click', () => {
        STATE.timer.pause();
      });

      function makeCollapsible(seed, display = 'block') {
        const button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.classList.add('collapsible');
        button.textContent = seed;
        button.addEventListener('click', function() {
          this.classList.toggle('active');
          const content = this.nextElementSibling;
          if (content.style.display === display) {
            content.style.display = 'none';
          } else {
            content.style.display = display;
          }
        });
        return button;
      }

      function displayPlayed(state, div, expanded) {
        const button = makeCollapsible('PLAYED: 0/0/0/0', 'table');
        const table = document.createElement('table');
        table.classList.add('collapsible-content');
        table.classList.add('results');
        table.classList.add('played');
        for (const {word, easy, group, defn} of state.played) {
          const tr = document.createElement('tr');
          if (group) {
            tr.classList.add('group');
          } else if (!easy) {
            tr.classList.add('hard');
          }

          let td = document.createElement('td');
          const b = document.createElement('b');
          b.textContent = word;
          td.appendChild(b);
          tr.appendChild(td);

          td = document.createElement('td');
          td.textContent = defn;
          tr.appendChild(td);

          table.appendChild(tr);
        }
        if (expanded) {
          button.classList.add('active');
          table.style.display = 'table';
        }
        div.appendChild(button);
        div.appendChild(table);
      }

      function displayPossible(state, div, expanded) {
        const button = makeCollapsible('POSSIBLE: 10/10/10/10', 'table');
        const table = document.createElement('table');
        table.classList.add('collapsible-content');
        table.classList.add('results');
        table.classList.add('possible');
        for (const {word, easy, group, defn} of state.possible) {
          const tr = document.createElement('tr');
          if (group) {
            tr.classList.add('group');
          } else if (!easy) {
            tr.classList.add('hard');
          }

          let td = document.createElement('td');
          const b = document.createElement('b');
          b.textContent = word;
          td.appendChild(b);
          tr.appendChild(td);

          td = document.createElement('td');
          td.textContent = defn;
          tr.appendChild(td);

          table.appendChild(tr);
        }
        if (expanded) {
          button.classList.add('active');
          table.style.display = 'table';
        }
        div.appendChild(button);
        div.appendChild(table);
      }

      document.getElementById('score').addEventListener('click', () => {
        const display = document.getElementById('display');
        const board = document.getElementById('board');
        const wrapper = document.getElementById('wrapper');
        if (!wrapper) {
          board.classList.add('hidden');
          word.classList.add('hidden');
          defn.classList.add('hidden');

          const wrapper = document.createElement('div');
          wrapper.setAttribute('id', 'wrapper');

          // TODO iterate through ALL states...
          const state = STATE.game.state();
          // TODO remember collapsible state..., also stop recalculating solutions of old games (on demand, then cache)
          const current = makeCollapsible(STATE.game.toJSON().seed); // FIXME INCLUDE PERCENT
          const div = document.createElement('div');
          div.classList.add('collapsible-content');
          displayPlayed(state, div, true); // TODO only current played...
          displayPossible(state, div);
          wrapper.appendChild(current);
          wrapper.appendChild(div);
          
          // Start off with played expanded
          current.classList.add('active');
          div.style.display = 'block';


          display.appendChild(wrapper);
        } else {
          display.removeChild(wrapper);
          board.classList.remove('hidden');
          word.classList.remove('hidden');
          defn.classList.remove('hidden');
        }
      });

      // TODO shouldnt work when in score mode!
      document.addEventListener('keydown', e => {
        if (kept) clearWord();
        word.focus(); // TODO fix cursor locaton
        const key = e.keyCode;
        if (key === 13 || key === 32) {
          play(STATE, word);
          e.preventDefault(); 
          word.focus();
        } else if ((key < 65 || key > 90) && key !== 8) {
          e.preventDefault();
        }
      });
    })();
  </script>
</body>
</html>
